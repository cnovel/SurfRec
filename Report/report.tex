\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{algpseudocode}
\usepackage{algorithm}

\title{Surface reconstruction\\
\large{CO512 ISO Report}}

\author{Cyril NOVEL}

\date{\today}

\begin{document}
\maketitle
\newpage

\tableofcontents

\newpage

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}
In the last decades, numerous devices have been developped in order to capture and digitize our world. Among them, 3D scanners aim at capturing the geometry of the objects surounding us. Statues, monuments but also industrial parts, landscapes : all these can be digitized into a 3D point cloud. But a 3D point cloud isn't enough for a correct visualization by human beings. Thus the reconstruction of the surface is needed to obtain a more comprehensible object.

Because of the numerous fields it covers -- cultural, industrial, medical -- Surface reconstruction is a widely studied subject in Computer Science. In this report, we will present the three main categories of algorithms used to perform surface reconstruction. For each category we will describe two or more precise algorithms.

\newpage

\section{Delaunay-based algorithms}
Delaunay-based algorithms are based on the Delaunay triangulation of a point cloud and the Voronoi diagram of a point cloud. In 2D, a Delaunay triangulation of a set of points $P$ is a triangulation such that no point in $P$ is inside the circumcircle of any triangle of the triangulation. We can generalize Delaunay triangulation in a $n$-dimension space, using simplex. For surface reconstruction, $n = 3$ so that the property becomes : a Delaunay triangulation of a set of points $P$ such that no point in $P$ is inside the circumspeher of any tetrahedron of the triangulation.

A Voronoi diagram is a way to divide the space. Given a set of points $\{p_i\}$,  for each point there will be a corresponding region $R_i = \{x | dist(p_i,x) < dist(p_j,x) ; i \ne j\}$. The regions are called Voronoi cells.

The Voronoi diagram is the dual of the Delaunay triangulation.

\subsection{General idea}
The Delaunay-based algorithm can be divided into two main steps. First, it computes a geometric triangulation of the finite set of points via the Delaunay triangulation or the Voronoi diagram. Then, it extracts a collection of facets chosen so that they are close to the actual surface.

The advantage of Delaunay-based algorithms is that the triangulation created is more robust than other approaches. Delaunay triangulation comes with a variety of theoretical guarantees. However, the Delaunay triangulation is very expensive to compute, thus these algorithms are very expensive for large point clouds.

We describe two different Delaunay based algorithms : the Power Crust algorithm and the Cocone algorithm.

\subsection{Power crust algorithm}
The Powercrust algorithm compute an approximate medial axis of the 3D point cloud $S$ using the Voronoi diagram. We then take a subset $V$ of the Voronoi vertices, called the poles. The poles lie near the medial axis. Each pole has an associated ball, called the polar ball. The polar balls approximate maximal balls contained in the interior or exterior of the 3D shape. The radii of the polar balls are the weights of the poles. The inverse transform is then approximate using the power diagram using the set of weighted poles.

The Power Crust algorithm can be summarize in 6 steps :
\begin{enumerate}
\item Compute the Voronoi diagram of the sample points $S$.
\item For each sample point, compute its poles.
\item Compute the power diagram of the poles.
\item Label each pole either inside or outside.
\item Output the power diagram faces separating the cells of inside and outside poles as the power crust.
\item Output the regular triangulation faces connecting inside poles as the power shape.
\end{enumerate}

The Power crust algorithm uses the notion of the \textit{Medial Axis Transform}. Let $F$ be the boundary of the 3D object. To avoid infinity edges and/or points, we assume that $F$ is contained in a bounded open region $Q$ -- for example a 3D box containing $F$. $F$ divides $Q$ into interior and exterior solids. Let $B_{c,r}$ be a ball of center $c$ and radius $r$. $B$ is empty if the interior of $B$ contains no point of $F$. A medial ball is a maximal empty ball, meaning that no other empty ball can completely contain it. The center of this medial ball is either a center of curvature of $F$ or a point with more than one closest point on $F$.

The \textit{Medial Axis Transform} of $F$ is the set of medial balls of F. The centers of the medial balls form the medial axis of $F$. The medial axis includes a part inside of $F$ and a part outside of $F$. The medial axis of a three-dimensional object is generally a two-dimensional surface.

Assuming a dense sampling, the Voronoi cell of every point of the data set is long, skinny and \textit{perpendicular} to the surface. It happens because in directions tangent to the surface the Voronoi cell is limited by the very close neighbors. So the Voronoi cell extends perpendicularly away from the surface and cannot extend farther than the medial axis. There it is not the closest point anymore -- due to the nature of the medial axis. Thus, the Voronoi vertices at the two ends of the long, skinny Voronoi cell should lie near the median axis. This motivates the selection of poles as an approximation of the median axis.


In pratice, the selection of the poles is done as follow : compute the Voronoi diagram of $S$, with a surrounding box of 8 vertices in order to avoid infinite edges. For each point $s \in S$, find the farthest vertex of the corresponding Voronoi cell, $p_1$. $p_1$ is the first pole of $s$. Then find the farthest vertex $p_2$ of the corresponding cell, such that $p_2.p_1 < 0$. $p_2$ is the second pole of $s$.

The inverse transform uses a \textit{power diagram}. A finite set of balls can be related to power diagrams, which are a kind of Voronoi diagrams, using the distance function :
$$d_{pow}(x, B_{c,r}) = d^2(c,x) - r^2$$
with $d$ the usual distance function in an euclidean space  $B_{c,r}$ the ball of center $c$ and radius $r$. Note that if $x$ is inside $B_{c,r}$, $d_{pow}$ is negative. We use $d_{pow}$ to define a Voronoi diagram, called the \textit{power diagram}.

Considering the power diagram of the polar balls, the \textit{power crust} is the boundary between the power diagrams cells belonging to inner poles and power diagramms cells belonging to outer poles. A facet of the power crust separates cells corresponding to an inner and an outer pole. With a dense sampling, the two polar balls should intersect only slightly, since the inner ball is mostly inside the object and the outer ball outside. The power crust actually interpolates the points of the original point cloud.

The previous paragraph stresses the fact that we need to label the poles as inner poles or outer poles. We define a graph such that two cells are connected in the graph if they share a two-dimensional face. Moreover, two faces are connected of they belong to the poles generated by the same point $s$. When $S$ is well-sampled, two properties can be extracted. The first is that an inner polar ball and an outer polar ball can only intersect shallowly. The second is that every sample as one unique inner pole and one unique outer pole. 

The first way to label the cells -- and therefore the poles -- is via a naive algorithm. It begins by labeling poles adjacent to the points of the bounding box as outer poles and propagates labels as follows. For any pole $p$ labeled outer, if it has an unlabeled neighbor $q$ such that the polar balls of $p$ and $q$ intersect deeply, we label $q$ as outer. Else, we label it as inner. Similarly for the inner poles: deeply intersecting polar balls get labeled as inner, else get labeled outer. The deepness of the intersection is calculated by the angle formed by the 2 tangent planes at the intersetion of the two polar balls.

Unfortunately, the sampling assumption is not true everywhere. If an error is made in the previous labelling algorithm, it propagates and leads to a wrong surface. A solution is to keep track of the belief that an unlabeled ball is inner or outer, based on the labels already assigned. Each ball keeps track of two values between 0 and 1. One value is the belief that the ball is in, the other the belief that the ball is out. If $belief(in) = 1$, we are certain that the ball is an inner ball. If $belief(in) = 0$, the state of the ball is unknown. We initialize all poles close to the bounding box to $belief(out) = 1$ and for all the other balls', $belief(in) = belief(out) = 0$.
All the remaining unlabeled poles are put in a priority queue. The priority is determined by the $belief(in)$ and $belief(out)$ values. If one of these two values is zero, we use the other for the priority queue. If both are non-zero, the pole is \textit{confused} and is assigned priority $|in - out| - 1$, which is between 0 and -1.

Then repeatedly, we remove the top element of the queue and label it inner or outer, depending on the biggest value. We then computes the new belief values for the remaining poles. If $p$ and $q$ are the two poles of a sample point $s$, $\beta$ denotes the angle between $p,s$ and $q,s$. We have $\pi/2 < \beta < \pi$. The bigger $\beta$ is, the more likely it is that $q$ shoud get opposite label from $p$. So we use $0 \le -cos\beta \le 1$ as the weight of the connection between $p$ and $q$. We note $tmp(p)$ the maximum value of $belief(in)(p)$ and $belief(out)(p)$. If $p$ is labeled as inner, then $belief(out)(q) = max(tmp(p)*-cos\beta, belief(out)(q))$.

We know that two balls with different lables intersect shallowly. So the deeper the intersection, the more likely the two balls will have the same label. So we set the weight to be $0 \le -cos\alpha \le 1$. So if $p$ is labeled as inner, then $belief(in)(q) = max(tmp(p)*-cos\alpha, belief(in)(q))$.

We have the two rules for updating the priority queue. We just have to loop until every pole is labeled, and then extract the power crust.

\subsection{Cocone algorithm}

\newpage

\section{Region-growing algorithms}
\subsection{General idea}
A classic region-growing algorithm begins by initiating a triangle as an initial region and then iterates to link new triangles on the region's boundaries. This type of algorithm is very fast. Most of the time, each point of the point cloud is considered only once for the triangulation. The disadvantage is that the reconstruction relies heavily on parameters chosen by the user and on the sampling of the point cloud. Moreover this method can create small holes in the surface when poor data  exists -- due to noise for example. 

We describe two different region-growing algorithms : the Ball Point algorithm and the Fast Reconstruction algorithm of the Point Cloud Library.

\subsection{Ball Point algorithm}
The idea of the BPA is very simple : three points form a triangle if a ball of radius $\rho$ touches them without containing any other points. Starting with a seed triangle, the sphere pivots around an edge of the triangle until it touches another point. It then formed a new triangle. We loop this process until all reachable edges have been considered.

Let $M$ be the surface of the 3D object and $S$ be the sampling points of $M$. For every point $s \in S$, we have the geometric position and the normal orientation. We make a sampling assumption: $S$ is dense enough so that no ball with radius $\rho$ can go through the surface without touching sample points.

% HERE SAMPLING ASSUMPTIONS

The BPA works by finding a seed triangle and use an advancing front to track which points have been visited and which are in the current boundary. The front $F$ is a collection of linked lists of edges. It is initialized by a single loop containing the three edges defined by the seed triangle. Each edge is represented by its two end points, the opposite vertex and the center of the ball that touches all three points. We classify the edge as \textit{active}, \textit{boundary} or \textit{frozen}. An \textit{active} edge will be used for pivoting. If the pivoting is impossible, then we classify it as \textit{boundary}. The \textit{frozen} state is explained a few paragraphs later, as it is useful in the context of out-of-core extensions. This information about the states of the edges allows a simpler and clearer algorithm for the pivoting of the ball. We do not use a single linked list because when the ball pivots around an edge, it can reach a new data point or a previously seen data point. Depending on this, the front changes topology. Algorithm~\ref{alg:bpa} shows the pseudocode for the Ball Pivoting Algorithm.

\begin{algorithm}
\caption{Ball Pivoting Algorithm}
\label{alg:bpa}
\begin{algorithmic}[5]
\While{$true$}
  \While{$e_{i,j} = get\_active\_edge(F)$}
    \If{$s_k = ball\_pivot(e_{i,j}) \&\& (not\_used(s_k) \| on\_front(s_k))$}
      \State $output\_triangle(s_i, s_k, s_j)$
      \State $join(e_{i,j}, s_k, F)$
      \If{$e_{k,i} \in F$}
        \State $glue(e_{i,k}, e_{k,i}, F)$
      \EndIf
      \If{$e_{j,k} \in F$}
        \State $glue(e_{k,j}, e_{j,k}, F)$
      \EndIf
    \Else
      \State $mark\_as\_boundary(e_{i,j})$
    \EndIf
  \EndWhile

  \If{$(s_i, s_j, s_k) = find_seed_triangle()$}
    \State $output\_triangle(s_i, s_j, s_k)$
    \State $insert\_edge(e_{i,j}, F)$
    \State $insert\_edge(e_{j,k}, F)$
    \State $insert\_edge(e_{k,i}, F)$
  \Else
    \State $return$
  \EndIf
\EndWhile
\end{algorithmic}
\end{algorithm} 

Two functions -- $ball\_pivot$ and $find\_seed\_triangle$ -- need an efficient way to retrieve the neighbourhood of a point. A simple solution is using a grid of small cubes, called voxels. The voxel's side is $\delta = 2\rho$. We store the data points in a list for each voxels. Given a point $s$, we can find the voxel $v$ it lies in by divided its coordinates by $\delta$. In order to look at every point that lies at a distance $\rho$ of $s$, we need to look at all the neighbours of $v$. Hence a total of 27 voxels to consider.

The selection of a seed

\subsection{Fast Reconstruction algorithm (PCL)}
\newpage

\section{Implicit surface algorithms}
\subsection{General idea}
In an implicit surface algorithm, a signed distance function is defined from the sample points and computed. Then given the zero-set of the signed distance function, an approximate triangulated surface is constructed.

There is a major difference between Implicit surface algorithms and Region-growing or Delaunay-based algorithms. Region-growing and Delaunay based methods interpolate sample points, mean that the reconstructed surface lies on the sample points. The implicit surface approach approximates sample points and can lack accuracy. But one advantage is that implicit surface methods are ideal in the case of highly noised data.

We describe four different implicit surface algorithms : the Poisson algorithm, the Radial Basis Function algorithm, the Level Set algorithm and the Marching Cubes algorithm.


\subsection{Poisson algorithm}

\subsection{Radial Basis Function algorithm}

\subsection{Level Set algorithm}

\subsection{Marching cubes algorithm}


\section*{Conclusion}
\addcontentsline{toc}{section}{Conclusion}
\end{document}
